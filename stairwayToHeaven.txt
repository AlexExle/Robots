#samewindow
//stairway
#line 0 solid #911e42 

//шаг лесенки
extern step = 50;
//начальный сдвиг 
extern offset = 0;
//размер доли
extern quantityOfShare = 22;
//количество шагов цены на которое будет изменяться цена активации заявок на вход в позицию
extern priceStepCount = 5;

extern lotSize = 0;

extern isForts = 1;

extern "string" clientId = "client";

static currentPoint = 0;

static lowPoint;

static highPoint;
//id текущего стопа
static curStopOrder;
//id позиции на шорт
static curShortOrder;
//id позиции на лонг
static curLongOrder;
// цена входа
static enterPrice;
// коэффициент выставления заявки
static quantityRate;
static position;
static fortsPositionSize = 0;

function init()
{
	setClient(clientId);
	position = 0;
	quantityRate = 1;
	if (offset >= step) {
		lackHistory();
	}
	requestFORTSPositions(clientId);
 
	currentPoint = open;
	currentPoint = currentPoint - fmod(currentPoint, step) + offset;
	line[0] = currentPoint;
	lowPoint = currentPoint - step;
	highPoint = currentPoint + step;
}

function getSecBalanceWrapper()
{
	if (isForts == 0)
	{
		return getSecBalance();
	}
	else
	{
		return fortsPositionSize;
	}
}

function onEnvEvent(var event)
{
  if (event == "CLIENT_HOLDINGS") {
		var secInf = getSecInfo();
		var fortsPos = getFORTSPosition(clientId, secInf["secid"]);    
		signal::output("secInf :" + secInf["secid"]);
		signal::output("getClient :" + clientId);
		signal::output("FORST position :" + fortsPos["totalnet"]);
		
		fortsPositionSize = fortsPos["totalnet"];
  }
}

function getSecPriceStep()
{
	var secInfo = getSecInfo();
	return as_number(secInfo["minstep"]);
}

function getSecLotSize()
{
	if (lotSize == 0) {
		var secInfo = getSecInfo();
		return as_number(secInfo["lotsize"]);
	}
	else {
		return lotSize;
	}
}

function calculateSharesCount()
{
	var	result = round(
				 abs(
					getSecBalanceWrapper()
					)/getSecLotSize()
					/quantityOfShare
				);
	

	signal::output("shares :" + result);
	return result;
}

//рассчет размера входа
function calcQuantity(var shares)
{		
	return (quantityOfShare * shares);
}

//функция для установки ордера (кредит включен!)
function setOrder(var orderType, var price, var quantity, var condition, var conditionPrice)
{
	if (quantity == 0 || price == 0 || conditionPrice == 0)
	{
		return 0;
	}
	var order = new_object("hash");

	// Заполнение парамеров хеша
	order["operation"] = orderType;
	order["quantity"] = quantity;
	if (isForts > 0)
	{
		order["usecredit"] = false;
	}
	else
	{
		order["usecredit"] = true;
	}
	order["price"] = price;
	order["validbefore"] = TILL_CANCELED;
	order["condition"] = condition;
	order["condvalue"] = conditionPrice;

	// Выставление заявку на биржу
	return trade_action::transactMultiple(order);
}

//функция для установки стоп ордера
function setStopOrder(var orderType, var price)
{
	var stop = new_object("hash");

	// Заявка на продажу
	stop["operation"] = orderType;

	// Часть Stop Loss
	stop["sl_activationprice"] = price;
	stop["sl_quantity"] = "100%" ;
	stop["validbefore"] = TILL_CANCELED;

	// Выставление заявки на рынок
	return trade_action::transactMultiple(stop);
}

function getMin(var period)
{	
	var i = period * -1;
	var result = low[i];
	while(i < 0)
	{
		if(result > low[i])
		{
			result = low[i];
		}
		i = i + 1;
	}
	return result;
}

function getMax(var period)
{
	var i = period * -1;
	var result = high[i];
	while(i < 0)
	{
		if(result < high[i])
		{
			result = high[i];
		}
		i= i + 1;
	}
	return result;
}

//обновляем ордера
function updateOrders(var currentShare)
{
	//старые в утиль
	trade_action::cancelAllOrders();
	var activationPrice = 0;
	//заявки на обе стороны
	if (currentShare == 0)
	{	
		
		activationPrice = line[0] - step + (getSecPriceStep()* priceStepCount) ;
		curShortOrder = setOrder(OP_SELL, line[0] - step, calcQuantity(1), COND_ASK, activationPrice );
		if (not curShortOrder) 
		{
			  signal::output(getLastErrorMessage());
		}
		else
		{
		   signal::output("Заявка на ШОРТ: " + line[0] + "| цена активации: " + activationPrice);
		}
		
		activationPrice = line[0] + step - (getSecPriceStep()* priceStepCount);
		curLongOrder = setOrder(OP_BUY, line[0] + step , calcQuantity(1), COND_BID, activationPrice);
		if (not curLongOrder) 
		{
		  signal::output(getLastErrorMessage());
		}
		else
		{
			signal::output("Заявка на ЛОНГ: " + line[0] + " цена активации: " + activationPrice );
		}
	}
	if (currentShare == 1)
	{	
		//в лонге
		if (getSecBalanceWrapper() > 0)
		{
			activationPrice = line[0] - step + (getSecPriceStep()* priceStepCount) ;
			curShortOrder = setOrder(OP_SELL, line[0] - step, calcQuantity(3), COND_ASK, activationPrice );
			if (not curShortOrder) 
			{
				  signal::output(getLastErrorMessage());
			}
			else
			{
			   signal::output("Заявка на ШОРТ: " + line[0] + "| цена активации: " + activationPrice);
			}
		}
		else // в шорте
		{			
			activationPrice = line[0] + step - (getSecPriceStep()* priceStepCount);
			curLongOrder = setOrder(OP_BUY, line[0] + step , calcQuantity(3), COND_BID, activationPrice);
			if (not curLongOrder) 
			{
			  signal::output(getLastErrorMessage());
			}
			else
			{
				signal::output("Заявка на ЛОНГ: " + line[0] + " цена активации: " + activationPrice );
			}
		}
	}
	if (currentShare == 2)
	{
		//в лонге
		if (getSecBalanceWrapper() > 0)
		{
			activationPrice = line[0] - step + (getSecPriceStep()* priceStepCount) ;
			curShortOrder = setOrder(OP_SELL, line[0] - step, calcQuantity(4), COND_ASK, activationPrice );
			if (not curShortOrder) 
			{
				  signal::output(getLastErrorMessage());
			}
			else
			{
			   signal::output("Заявка на ШОРТ: " + line[0] + "| цена активации: " + activationPrice);
			}
			
			activationPrice = line[0] + step - (getSecPriceStep()* priceStepCount);
			curLongOrder = setOrder(OP_SELL, line[0] + step , calcQuantity(1), COND_BID, activationPrice);
			if (not curLongOrder) 
			{
			  signal::output(getLastErrorMessage());
			}
			else
			{
				signal::output("Заявка на ШОРТ, выход до одной доли: " + line[0] + " цена активации: " + activationPrice );
			}		
		}
		else // в шорте
		{
		
			activationPrice = line[0] - step + (getSecPriceStep()* priceStepCount) ;
			curShortOrder = setOrder(OP_SELL, line[0] - step, calcQuantity(1), COND_ASK, activationPrice );
			if (not curShortOrder) 
			{
				  signal::output(getLastErrorMessage());
			}
			else
			{
			   signal::output("Заявка на ЛОНГ, выход до одной доли: " + line[0] + "| цена активации: " + activationPrice);
			}
			
			activationPrice = line[0] + step - (getSecPriceStep()* priceStepCount);
			curLongOrder = setOrder(OP_BUY, line[0] + step , calcQuantity(4), COND_BID, activationPrice);
			if (not curLongOrder) 
			{
			  signal::output(getLastErrorMessage());
			}
			else
			{
				signal::output("Заявка на ЛОНГ: " + line[0] + " цена активации: " + activationPrice );
			}
		}
	}
	
}

//обновляем стопы
function updateStopOrder()
{
	trade_action::cancelAllOrders();
	trade_action::cancelStopOrder(curStopOrder);
	//бумаг > 0? стоим в лонге, значит стоп-заявка на шорт
	if(getSecBalance()> 0)
	{
		curStopOrder = setStopOrder(OP_SELL, line[3]);
	}
	else
	{
		if (getSecBalance() < 0)
		{
			curStopOrder = setStopOrder(OP_BUY, line[2]);
		}
	}
	
	if (not curStopOrder) 
	{
		  signal::output(getLastErrorMessage());
	}
	else
	{
		signal::output("Обновили стоп.");
	}
}


//по ордеру мы должны смотреть закрылся ли ордер, если да, то делаем то что нужно после полного входа
function onOrder(var id)
{
	var order = getOrder(id);
	
	if (order["status"] == OS_MATCHED)
	{
		var price =	order["price"];
		
		var newShares = calculateSharesCount();
		signal::output("Выполнена заявка! Новое количество долей :" + newShares);
		updateOrders(newShares);		
	}
}

function onTrade(var id) 
{
	var trade = getTrade(id);

	if (isForts > 0 )
	{
		fortsPositionSize = trade["currentpos"];
	}
}

function calc()
{
	if(line[0] == 0)
	{
		line[0] = currentPoint;
	}
	if (high >= highPoint)
	{
	   line[0] = highPoint;
	   currentPoint = highPoint;
	   lowPoint =  highPoint - step;
	   highPoint = highPoint + step;		   
	}
	else
	{ if (low <= lowPoint) 
	  {
		 line[0] = lowPoint;
		 currentPoint = lowPoint;
		 highPoint = lowPoint + step;		   
		 lowPoint = lowPoint - step;		     
	  }
	}
}


function onNewCandle() 
{	
	var orders = getActiveOrderIDs();
	if(getSecBalanceWrapper() == 0 && orders.size() == 0)
	{
		updateOrders(0);
	}	
	
	if (isForts > 0)
	{
		signal::output("Current position :" + getSecBalanceWrapper());
	}
}

// BUTTONS FOR TESTING //

//Shift + 1
function onKeyDown(var key)
{
  if (key == chr2num("1") and isKeyPressed(KEY_LSHIFT)) 
  {
     signal::outputMultiple("FORST position :" + getSecBalanceWrapper());
  }
  if (key == chr2num("2") and isKeyPressed(KEY_LSHIFT)) 
  {
	var newShares = calculateSharesCount();
	signal::output("Обновляев заявки. Текущее кол-во долей :" + newShares);
	updateOrders(newShares);		
  }
}
