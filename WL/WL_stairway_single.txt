using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using WealthLab;
using WealthLab.Indicators;
using System.Drawing;


namespace ClassLibrary1
{
	class MyStrategyScript : WealthScript
	{
		//Create parameters


		private StrategyParameter StepPar;
		private StrategyParameter Offset;

		double fullEquity = 800000; //”казываем здесь весь счета
		double Equity = 400000; //”казываем здесь начальный счета
		int SharesInLot = 1; //показываем, сколько акций содержитс€ в лоте (дл€ каждого вида акций свое количество акций в лоте)
		double Shares = 0; //расчетное количество акций (еще не кратное лотам) изначально равн€етс€ нулю рассчитываетс€ при входе в позицию.
		double Rate = 1;

		double CurrLevel = 0;

		double HighLevel = 0;

		double LowLevel = 0;

		int posCount = 0;
		int positionCOunt = 0;
		List<double> values = new List<double>();
		public MyStrategyScript()
		{
			Offset = CreateParameter("Offser", 0, 0, 300, 10);
			StepPar = CreateParameter("Step", 100, 50, 300, 10);
			//maxTakeProfitPercent = CreateParameter("Max take profit", 6, 0, 20, 0.25);
			//reverseMode = CreateParameter("Reverse mode", 0, 0, 1, 1);
		}

		protected override void Execute()
		{
			//Obtain periods from parameters
	
			if (StepPar.Value < Offset.Value)
				return;
			double startPoint = Open[0];
            
			startPoint = startPoint - (startPoint % 10);
			double previousPoint = 0;
			for (int bar = 1; bar < Bars.Count; bar++)
			{
				if (startPoint > Low[bar] && startPoint < High[bar])
				{
					previousPoint = startPoint;
					startPoint = 0;
				}

			}

			// High - массив хаев дл€ всех свечей
			// Low - массив лоувов дл€ всех свечей
		
            
			DataSeries newDataSeries = new DataSeries("Test");
            
			CurrLevel = Open[0];
			CurrLevel = CurrLevel - (CurrLevel % StepPar.Value) + Offset.Value;
			newDataSeries.Add(CurrLevel);
			HighLevel = CurrLevel + StepPar.Value;
			LowLevel = CurrLevel - StepPar.Value;
            /*currentPoint = open;
            currentPoint = currentPoint - fmod(currentPoint, step) + offset;
            line[0] = currentPoint;
            lowPoint = currentPoint - step;
            highPoint = currentPoint + step;*/
            
            // shift the plotted series to the right one bar to visualize the crossings           

			for (int bar = 1; bar < Bars.Count; bar++)
			{                

			
				if (Positions.Count == 0)
				{
					if (BuyAtStop(bar + 1, HighLevel) == null)
					{

						ShortAtStop(bar + 1, LowLevel);
					}
				}
				else
				{
					Position Pos = LastPosition;
					if (Pos.PositionType == PositionType.Long)
					{
						if (SellAtStop(bar + 1, Pos, LowLevel))
							ShortAtStop(bar + 1, LowLevel, "Short Over Turn");
					}
					else
					{
						if (CoverAtStop(bar + 1, LastPosition, HighLevel))
							Pos = BuyAtStop(bar + 1, HighLevel, "Longg ver Turn");
					}
				}
				if (High[bar] >= HighLevel)
				{
					CurrLevel = HighLevel;
					LowLevel = CurrLevel - StepPar.Value;
					HighLevel = CurrLevel + StepPar.Value;
				}
				else
				{
					if (Low[bar] <= LowLevel)
					{
						CurrLevel = LowLevel;
						LowLevel = CurrLevel - StepPar.Value;
						HighLevel = CurrLevel + StepPar.Value;
					}
				}
				newDataSeries.Add(CurrLevel);           
			}
			PlotSeries(PricePane, newDataSeries, Color.Green, LineStyle.Solid, 1);
		}

		public void CalcPositionSize(int bar)
		{
			//„тобы добитьс€ кратности можно воспользоватьс€ при программировании следующей логики:
			//int SharesInLot = 10; //показываем, сколько акций содержитс€ в лоте (дл€ каждого вида акций свое количество акций в лоте)
			//int Shares = 118; //каким либо методом рассчитываем, сколько нужно акций купить.
			//SetShareSize(Shares - Shares % SharesInLot); //определ€ем количество акций, кратное лоту.
			//¬ыражение: (Shares % SharesInLot) дает в итоге остаток от делени€ 118 на 10 (т.е. 8) 
			//¬ итоге получаетс€: 118-8 = 110
			//110 кратно дес€ти, так что в итоге купитс€ 110 акций (или 11 лотов).
			var eq = (Equity * Rate);
			if (eq > fullEquity)
				eq = fullEquity;
			Shares = (int)(eq / (Close[bar]));
			SetShareSize(System.Math.Floor(Shares - Shares % SharesInLot)); //внутри метода определ€ем количество акций, которое кратно лоту.
		}
	}
}



